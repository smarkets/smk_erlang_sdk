As mentioned in the README the message payloads passed between clients and Smarkets are each assigned an incrementing sequence number as to maintain an ordered sequence of events known to both parties. If either side of the communication crashes at any point after receiving a message it can recover by sending a replay payload to the other party with the sequence number of the last message that it has definitely received and handled appropriately.

The aim of using this manner of asyncronous message passing is to maintain high throughput while also guaranteeing delivery and message handling on both ends of the communication channel. 

This is based on (but not an implementation of) the fundamentals of the Financial Information eXchange Protocol (FIX) used for real-time electronic exchange of securities transactions. http://www.fixprotocol.org/

== Life of a Session ==

A session on the Smarkets Async API is created when a TCP connection is made and a login message is sent and successfully processed by Smarkets. This message will need to start with sequence number 1 and will look like this in erlang:

    Msg = #seto_message{
        seq = 1,
        payload = {login,
          #seto_login_payload{
            username = <<"youremail@host.com">>,
            password = <<"yourpassword">>
          }}},

Due to using Piqi http://piqi.org/ serialization to binary is compatible with Protocol-Buffers http://code.google.com/p/protobuf/ and is done by called the following:

    BinaryMsg = seto_piqi:gen_message(Msg),

After this you can send it down the TCP connection:

    ok = gen_tcp:send(Sock, BinaryMsg),

Framing is not currently supported meaning you are restricted to sending one message at a time using gen_tcp:send or else your session will be disconnected. This will change.

When receiving messages back from the Smarkets the opposite call to deserialize the incoming socket data is:

    Msg = seto_piqi:parse_message(Data),

If your Erlang application exits for any reason and you lose connection with Smarkets you can resume the existing session by issuing the 'session' key to the #seto_login_payload record along with the username and password. The 'session' value should be retrieving from the #seto_login_response record sent back from Smarkets after the original login (with seq 1). As well as adding the 'session' key to the login payload you also *must* ensure the sequence number for this message is the next sequence number you would have sent *before* disconnecting, meaning that this new login message is *not* sequence 1, this is so that the the session can be correctly resumed and any missing messages re-requested if either side.

== Re-Request / Replaying Messages ==

If a message is not correctly handled by either side of the connection a sequence number inconsistency may occur. This is when one side expects an incoming message with a specific sequence number but receives one that is larger. When this is detected a replay payload needs to be sent and handled by the other party by resending each of the missing messages along with the extra value replay=true to the #seto_message record.

In the following example the server A sends message #8 but the client B expects message #5, possibly because it had crashed before fully processing the TCP Packets that it was sent:

             A | {seq=8, payload=ping} ---------------> | B
               |                                        | expects in #5
               | <------------ {seq=4, payload={replay, |
 expects in #4 |          #seto_replay_payload{seq=5}}} |
               |                                        |
               | {seq=5, replay=true, payload=...} ---> | expects in #5
               | {seq=6, replay=true, payload=...} ---> | expects in #6
               | {seq=7, replay=true, payload=...} ---> | expects in #7
               | {seq=8, replay=true, payload=ping} --> | expects in #8
               |                                        | 
 expects in #5 | <--------------- {seq=5, payload=pong} | 

This means that both the server and client need to keep a log of all outgoing messages in sequence numbered order. If this is not done then the session will become useless and eventually get disconnected and a new connection and session will need to be made. In smk_example_client the gen_server smk_example_message_cache is used to maintain a 20 message cache, which might be adequate for lower throughput clients but for clients that want to deal with large numbers of orders a better approach that caches to disk and can be recovered from incase of crashes should be consider.
